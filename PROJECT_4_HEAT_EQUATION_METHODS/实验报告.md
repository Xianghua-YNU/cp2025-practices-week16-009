# 项目：热传导方程数值解法比较 - 实验报告

**学生姓名：** [余维] 

**学号：** [20231050005] 

**完成日期：** [2025/6/11]

## 1. 实验目的

本实验旨在通过实现和比较四种不同的数值方法求解一维热传导方程，深入理解偏微分方程数值解法的特点、稳定性和精度问题。

## 2. 理论背景

### 2.1 热传导方程

一维热传导方程的数学形式为：

$$\frac{\partial u}{\partial t} = \alpha \frac{\partial^2 u}{\partial x^2}$$

其中：
- $u(x,t)$ 是温度分布函数
- $\alpha$ 是热扩散系数
- 边界条件： $u(0,t) = u(L,t) = 0$
- 初始条件： $u(x,0) = f(x)$

### 2.2 数值方法概述

1. **显式差分法（FTCS）**：前向时间，中心空间差分
2. **隐式差分法（BTCS）**：后向时间，中心空间差分
3. **Crank-Nicolson方法**：时间方向二阶精度的隐式方法
4. **solve_ivp方法**：将PDE转化为ODE系统求解

## 3. 算法实现

### 3.1 显式差分法

**核心思想：** [显式差分法（FTCS）使用前向差分近似时间导数，中心差分近似空间导数。当前时间步的温度分布直接由上一个时间步的值显式计算得到，无需求解方程组。]

**稳定性条件：** $r = \frac{\alpha \Delta t}{(\Delta x)^2} \leq 0.5$

**关键代码片段：**
```python
# # 稳定性检查
r = self.alpha * dt / (self.dx**2)
if r > 0.5:
    print(f"Warning: Stability condition violated! r = {r:.4f} > 0.5")

# 时间步进
for n in range(1, nt):
    # 使用拉普拉斯算子计算二阶导数
    du_dt = r * laplace(u)
    u += du_dt

    # 应用边界条件
    u[0] = 0.0
    u[-1] = 0.0
```

### 3.2 隐式差分法

**核心思想：** [隐式差分法（BTCS）使用后向差分近似时间导数，中心差分近似空间导数。每个时间步需要求解一个线性系统，因为新时间步的值同时依赖于旧时间步的值和同时间步相邻点的值。]

**优势：** 无条件稳定

**关键代码片段：**
```python
# 构建三对角矩阵
banded_matrix = np.zeros((3, num_internal))
banded_matrix[0, 1:] = -r  # 上对角线
banded_matrix[1, :] = 1 + 2*r  # 主对角线
banded_matrix[2, :-1] = -r  # 下对角线

# 时间步进
for n in range(1, nt):
    rhs = u[1:-1].copy()  # 右侧向量
    # 求解三对角系统
    u_internal_new = scipy.linalg.solve_banded((1, 1), banded_matrix, rhs)
    u[1:-1] = u_internal_new
    u[0] = 0.0
    u[-1] = 0.0
```

### 3.3 Crank-Nicolson方法

**核心思想：** [Crank-Nicolson方法在时间上是二阶精度的隐式方法。它取显式格式和隐式格式的平均，从而在时间和空间上都具有二阶精度。]

**精度：** 时间和空间都是二阶精度

**关键代码片段：**
```python
# 构建系数矩阵A
banded_matrix_A = np.zeros((3, num_internal))
banded_matrix_A[0, 1:] = -r/2  # 上对角线
banded_matrix_A[1, :] = 1 + r  # 主对角线
banded_matrix_A[2, :-1] = -r/2  # 下对角线

# 时间步进
for n in range(1, nt):
    # 计算右侧向量
    u_internal = u[1:-1]
    rhs = (r/2) * u[:-2] + (1 - r) * u_internal + (r/2) * u[2:]

    # 求解系统
    u_internal_new = scipy.linalg.solve_banded((1, 1), banded_matrix_A, rhs)
    u[1:-1] = u_internal_new
    u[0] = 0.0
    u[-1] = 0.0
```

### 3.4 solve_ivp方法

**核心思想：** [将空间离散化后，热传导方程转化为一个常微分方程组（ODE），然后使用SciPy的solve_ivp方法求解。该方法使用自适应步长控制，能够根据需要调整步长以保证精度。]

**优势：** 自适应步长，高精度

**关键代码片段：**
```python
def _heat_equation_ode(self, t, u_internal):
    # 重建完整解（包括边界）
    u_full = np.concatenate(([0.0], u_internal, [0.0]))
    # 计算二阶导数
    d2u_dx2 = laplace(u_full) / (self.dx**2)
    # 返回内部节点的导数
    return self.alpha * d2u_dx2[1:-1]

# 调用solve_ivp
sol = solve_ivp(
    fun=self._heat_equation_ode,
    t_span=(0, self.T_final),
    y0=u0_internal,
    method=method,
    t_eval=plot_times,
    rtol=1e-8,
    atol=1e-10
)
```

## 4. 实验结果

### 4.1  数值结果

#### 4.1.1 温度分布演化

[![屏幕截图 2025-06-11 115245](https://github.com/user-attachments/assets/55441dd2-b2fc-4383-9e37-bd84fa8eb574)
]

#### 4.1.2 计算效率比较

| 方法 | 计算时间 (秒) | 时间步数 | 效率评价 |
|------|---------------|----------|----------|
| 显式差分法 | [0.0386] | [2500] | [中等 (受步长限制)] |
| 隐式差分法 | [0.0049] | [250] | [较高] |
| Crank-Nicolson | [0.0014] | [50] | [最高] |
| solve_ivp | [0.1174] | [自适应] | [较低 (高精度代价)] |

#### 4.2.3 精度分析

以solve_ivp方法作为参考解，计算其他方法的相对误差：

| 方法 | 最大相对误差 | 平均相对误差 | 精度评价 |
|------|--------------|--------------|----------|
| 显式差分法 | [1.67e-03] | [4.07e-04] | [高精度] |
| 隐式差分法 | [1.66e-02] | [4.03e-03] | [中等精度] |
| Crank-Nicolson | [3.98e-01] | [8.74e-02] | [低精度(步长大)] |

### 4.3 稳定性验证

#### 4.3.1 显式方法稳定性

- 稳定性参数： $r =$ [0.1]
- 稳定性判断：[稳定]
- 观察现象：[数值解平滑扩散，无振荡或发散]

#### 4.3.2 隐式方法稳定性

- 大时间步长测试： $\Delta t =$ [10]
- 稳定性表现：[解保持稳定，无振荡发散现象]

## 5. 结果分析与讨论

### 5.1 方法比较

#### 5.1.1 精度比较

[分析各方法的精度特点，解释精度差异的原因
显式差分法精度最高，因其采用小时间步长(0.01s)。Crank-Nicolson精度最低，因其使用大时间步长(0.5s)。隐式方法精度中等，平衡了步长和精度。精度差异主要源于：

时间步长大小

离散化误差阶数(显式O(Δt), 隐式O(Δt), CN-O(Δt²))

大步长放大截断误差]

#### 5.1.2 效率比较

[分析各方法的计算效率，讨论时间步长限制的影响
Crank-Nicolson效率最高(0.0014s)，因其：

无条件稳定，允许大时间步长(0.5s)

三对角矩阵高效求解
显式方法效率受限(0.0386s)，因稳定性要求小步长(0.01s)。solve_ivp效率最低(0.1174s)，因其自适应步长和高精度计算开销大。]

#### 5.1.3 稳定性比较

[显式方法：条件稳定(r≤0.5)，物理意义为热扩散速率需满足CFL条件

隐式/CN：无条件稳定，允许任意步长

稳定性物理意义：保证数值扰动不会指数增长]

### 5.2 物理现象分析

#### 5.2.1 热扩散过程

[初始时刻：热源集中在[10,11]区间

t=1s：热量向两侧扩散，峰值降低

t=5s：温度分布呈钟形曲线

t=25s：热量均匀扩散，趋近于零(边界吸收)]

#### 5.2.2 边界条件影响

[零边界条件(两端温度固定为0)导致：

热量持续从边界散失

最终温度全场趋近于零

限制热扩散范围]

### 5.3 数值方法选择建议

根据实验结果，针对不同应用场景提出方法选择建议：

1. **高精度要求**：[solve_ivp	自适应步长保证高精度]
2. **快速计算**：[Crank-Nicolson	大时间步长+高效矩阵求解]
3. **长时间模拟**：[隐式差分法	无条件稳定+中等计算开销]
4. **实时应用**：[Crank-Nicolson	快速响应+稳定性好]

## 6. 问题与收获

### 6.1 遇到的主要问题

1. **[问题1]**：[初始使用较大步长(>0.05)导致解振荡发散]
   - 解决方法：[添加稳定性检查(r≤0.5)，自动警告并建议步长]
   - 经验总结：[显式方法必须严格满足CFL条件]

2. **[问题2]**：[隐式方法矩阵构建索引错误]
   - 解决方法：[采用scipy.linalg.solve_banded专门求解]
   - 经验总结：[利用科学计算库提升开发效率]

### 6.2 主要收获

1. **理论理解**：[掌握FTCS、BTCS、CN格式的稳定性与精度特性

理解PDE离散化中截断误差来源]
2. **编程技能**：[熟练使用scipy科学计算栈(solve_banded, solve_ivp)

实现高效三对角矩阵求解]
3. **科学计算思维**：[精度-效率-稳定性权衡策略

数值方法适用场景分析能力]
4. **问题解决能力**：[调试数值不稳定现象

设计自动化比较框架]

## 7. 思考题

### 7.1 稳定性分析

为什么显式差分法需要满足稳定性条件 $r \leq 0.5$，而隐式方法无条件稳定？请从数学角度分析。

**答案：** [显式方法中，时间步进是显式的，误差会逐步放大。通过冯·诺依曼稳定性分析，可以得到增长因子$G = 1 - 4r\sin^2(k\Delta x/2)$。稳定性要求$|G| \leq 1$，这导出$r \leq 0.5$。隐式方法中，增长因子为$G = 1/(1 + 4r\sin^2(k\Delta x/2))$，分母总是大于分子，因此无条件稳定。]

### 7.2 精度提升

如何进一步提高数值解的精度？请提出至少两种方法并说明原理。

**答案：** [网格加密：减小$\Delta x$和$\Delta t$，但会增加计算量

高阶差分格式：使用四阶中心差分代替二阶中心差分

自适应时间步长：如solve_ivp已实现，根据局部误差估计调整步长

谱方法：使用傅里叶级数或切比雪夫多项式作为基函数]

### 7.3 实际应用

在实际工程问题中，如何根据具体需求选择合适的数值方法？

**答案：** [实时监控：显式方法（计算快，适合小规模问题）

长期模拟：隐式或Crank-Nicolson（允许大步长）

高精度要求：Crank-Nicolson或solve_ivp

复杂边界/源项：solve_ivp（灵活性高）

大规模并行计算：显式方法（易于并行化）]

### 7.4 扩展问题

如果要求解二维或三维热传导方程，各种方法的优缺点会如何变化？

**答案：** [显式方法：

优点：实现简单，易于并行化

缺点：稳定性条件更严格（2D: r ≤ 0.25, 3D: r ≤ 0.166），计算效率低

隐式方法：

优点：仍无条件稳定

缺点：需要求解大型稀疏矩阵，存储和计算成本高（特别是3D）

Crank-Nicolson：

优点：精度高

缺点：同隐式方法，矩阵求解更复杂

solve_ivp：

优点：自适应步长优势更明显

缺点：高维问题ODE系统规模剧增，计算成本高

替代方法：

交替方向隐式法(ADI)：将高维问题分解为一系列一维问题

多重网格法：高效求解椭圆型方程

有限元法：更适合复杂几何形状]

## 8. 完整代码

[#!/usr/bin/env python3
"""
Heat Equation Solver with Multiple Numerical Methods
File: heat_equation_methods_solution.py

该模块使用四种不同数值方法求解一维热传导方程：
1. 显式有限差分法 (FTCS)
2. 隐式有限差分法 (BTCS)
3. Crank-Nicolson 方法
4. scipy.integrate.solve_ivp 方法
"""

import numpy as np  # 导入数值计算库
import matplotlib.pyplot as plt  # 导入绘图库
from scipy.ndimage import laplace  # 导入拉普拉斯算子
from scipy.integrate import solve_ivp  # 导入ODE求解器
import scipy.linalg  # 导入线性代数工具
import time  # 导入时间模块

class HeatEquationSolver:
    """
    使用多种数值方法求解一维热传导方程的综合求解器
    
    热方程：du/dt = alpha * d²u/dx²
    边界条件：u(0,t) = 0, u(L,t) = 0
    初始条件：u(x,0) = phi(x)
    """
    
    def __init__(self, L=20.0, alpha=10.0, nx=21, T_final=25.0):
        """
        初始化热方程求解器
        
        参数：
            L (float): 区域长度 [0, L]
            alpha (float): 热扩散系数
            nx (int): 空间网格点数
            T_final (float): 最终模拟时间
        """
        self.L = L  # 区域长度
        self.alpha = alpha  # 热扩散系数
        self.nx = nx  # 空间网格点数
        self.T_final = T_final  # 最终模拟时间
        
        # 空间网格
        self.x = np.linspace(0, L, nx)  # 创建从0到L的等间距网格
        self.dx = L / (nx - 1)  # 计算空间步长
        
        # 初始化解数组
        self.u_initial = self._set_initial_condition()  # 设置初始条件
        
    def _set_initial_condition(self):
        """
        设置初始条件：u(x,0) = 1 (当 10 <= x <= 11), 其余为0
        
        返回：
            np.ndarray: 初始温度分布
        """
        u0 = np.zeros(self.nx)  # 创建全零数组
        mask = (self.x >= 10) & (self.x <= 11)  # 创建选择区域10-11的掩码
        u0[mask] = 1.0  # 将选择区域设为1
        # 应用边界条件
        u0[0] = 0.0  # 左边界
        u0[-1] = 0.0  # 右边界
        return u0  # 返回初始条件
    
    def solve_explicit(self, dt=0.01, plot_times=None):
        """
        使用显式有限差分法 (FTCS) 求解
        
        参数：
            dt (float): 时间步长
            plot_times (list): 需要绘图的时间点
            
        返回：
            dict: 包含时间点和温度数组的解决方案数据
        """
        if plot_times is None:  # 设置默认绘图时间点
            plot_times = [0, 1, 5, 15, 25]
            
        # 稳定性检查
        r = self.alpha * dt / (self.dx**2)  # 计算稳定性参数
        if r > 0.5:  # 检查显式方法的稳定性条件
            print(f"警告: 违反稳定性条件! r = {r:.4f} > 0.5")
            print(f"考虑减小 dt 到 < {0.5 * self.dx**2 / self.alpha:.6f}")
        
        # 初始化
        u = self.u_initial.copy()  # 复制初始条件
        t = 0.0  # 初始时间
        nt = int(self.T_final / dt) + 1  # 计算时间步数
        
        # 结果存储
        results = {'times': [], 'solutions': [], 'method': 'Explicit FTCS'}  # 创建结果字典
        
        # 存储初始条件
        if 0 in plot_times:  # 如果0在绘图时间点中
            results['times'].append(0.0)  # 记录时间
            results['solutions'].append(u.copy())  # 保存解
        
        start_time = time.time()  # 开始计时
        
        # 时间步进
        for n in range(1, nt):  # 遍历时间步
            # 使用scipy.ndimage.laplace应用拉普拉斯算子
            du_dt = r * laplace(u)  # 计算时间导数
            u += du_dt  # 更新解
            
            # 应用边界条件
            u[0] = 0.0  # 左边界
            u[-1] = 0.0  # 右边界
            
            t = n * dt  # 更新当前时间
            
            # 在指定时间存储解
            for plot_time in plot_times:  # 遍历所有绘图时间点
                # 检查当前时间是否接近绘图时间点
                if abs(t - plot_time) < dt/2 and plot_time not in [res_t for res_t in results['times']]:
                    results['times'].append(t)  # 记录时间
                    results['solutions'].append(u.copy())  # 保存解
        
        # 记录计算时间和稳定性参数
        results['computation_time'] = time.time() - start_time
        results['stability_parameter'] = r
        
        return results  # 返回结果
    
    def solve_implicit(self, dt=0.1, plot_times=None):
        """
        使用隐式有限差分法 (BTCS) 求解
        
        参数：
            dt (float): 时间步长
            plot_times (list): 需要绘图的时间点
            
        返回：
            dict: 包含时间点和温度数组的解决方案数据
        """
        if plot_times is None:  # 设置默认绘图时间点
            plot_times = [0, 1, 5, 15, 25]
            
        # 参数计算
        r = self.alpha * dt / (self.dx**2)  # 稳定性参数
        nt = int(self.T_final / dt) + 1  # 时间步数
        
        # 初始化
        u = self.u_initial.copy()  # 复制初始条件
        
        # 为内部节点构建三对角矩阵
        num_internal = self.nx - 2  # 内部节点数
        banded_matrix = np.zeros((3, num_internal))  # 创建带状矩阵
        banded_matrix[0, 1:] = -r  # 上对角线
        banded_matrix[1, :] = 1 + 2*r  # 主对角线
        banded_matrix[2, :-1] = -r  # 下对角线
        
        # 结果存储
        results = {'times': [], 'solutions': [], 'method': 'Implicit BTCS'}
        
        # 存储初始条件
        if 0 in plot_times:
            results['times'].append(0.0)
            results['solutions'].append(u.copy())
        
        start_time = time.time()  # 开始计时
        
        # 时间步进
        for n in range(1, nt):  # 遍历时间步
            # 右侧向量 (仅内部节点)
            rhs = u[1:-1].copy()  # 复制当前解的内部节点
            
            # 求解三对角系统
            u_internal_new = scipy.linalg.solve_banded((1, 1), banded_matrix, rhs)
            
            # 更新解
            u[1:-1] = u_internal_new  # 更新内部节点
            u[0] = 0.0  # 边界条件
            u[-1] = 0.0
            
            t = n * dt  # 更新当前时间
            
            # 在指定时间存储解
            for plot_time in plot_times:
                if abs(t - plot_time) < dt/2 and plot_time not in [res_t for res_t in results['times']]:
                    results['times'].append(t)
                    results['solutions'].append(u.copy())
        
        # 记录计算时间和稳定性参数
        results['computation_time'] = time.time() - start_time
        results['stability_parameter'] = r
        
        return results
    
    def solve_crank_nicolson(self, dt=0.5, plot_times=None):
        """
        使用 Crank-Nicolson 方法求解
        
        参数：
            dt (float): 时间步长
            plot_times (list): 需要绘图的时间点
            
        返回：
            dict: 包含时间点和温度数组的解决方案数据
        """
        if plot_times is None:  # 设置默认绘图时间点
            plot_times = [0, 1, 5, 15, 25]
            
        # 参数计算
        r = self.alpha * dt / (self.dx**2)  # 稳定性参数
        nt = int(self.T_final / dt) + 1  # 时间步数
        
        # 初始化
        u = self.u_initial.copy()  # 复制初始条件
        
        # 为内部节点构建系数矩阵
        num_internal = self.nx - 2  # 内部节点数
        
        # 左侧矩阵 A
        banded_matrix_A = np.zeros((3, num_internal))  # 创建带状矩阵
        banded_matrix_A[0, 1:] = -r/2  # 上对角线
        banded_matrix_A[1, :] = 1 + r  # 主对角线
        banded_matrix_A[2, :-1] = -r/2  # 下对角线
        
        # 结果存储
        results = {'times': [], 'solutions': [], 'method': 'Crank-Nicolson'}
        
        # 存储初始条件
        if 0 in plot_times:
            results['times'].append(0.0)
            results['solutions'].append(u.copy())
        
        start_time = time.time()  # 开始计时
        
        # 时间步进
        for n in range(1, nt):  # 遍历时间步
            # 右侧向量
            u_internal = u[1:-1]  # 当前解的内部节点
            # 计算右侧向量
            rhs = (r/2) * u[:-2] + (1 - r) * u_internal + (r/2) * u[2:]
            
            # 求解三对角系统 A * u^{n+1} = rhs
            u_internal_new = scipy.linalg.solve_banded((1, 1), banded_matrix_A, rhs)
            
            # 更新解
            u[1:-1] = u_internal_new  # 更新内部节点
            u[0] = 0.0  # 边界条件
            u[-1] = 0.0
            
            t = n * dt  # 更新当前时间
            
            # 在指定时间存储解
            for plot_time in plot_times:
                if abs(t - plot_time) < dt/2 and plot_time not in [res_t for res_t in results['times']]:
                    results['times'].append(t)
                    results['solutions'].append(u.copy())
        
        # 记录计算时间和稳定性参数
        results['computation_time'] = time.time() - start_time
        results['stability_parameter'] = r
        
        return results
    
    def _heat_equation_ode(self, t, u_internal):
        """
        solve_ivp 方法的 ODE 系统
        
        参数：
            t (float): 当前时间
            u_internal (np.ndarray): 内部节点温度
            
        返回：
            np.ndarray: 内部节点的时间导数
        """
        # 重建包含边界条件的完整解
        u_full = np.concatenate(([0.0], u_internal, [0.0]))
        
        # 使用拉普拉斯算子计算二阶导数
        d2u_dx2 = laplace(u_full) / (self.dx**2)
        
        # 仅返回内部节点的导数
        return self.alpha * d2u_dx2[1:-1]
    
    def solve_with_solve_ivp(self, method='BDF', plot_times=None):
        """
        使用 scipy.integrate.solve_ivp 求解
        
        参数：
            method (str): 积分方法 ('RK45', 'BDF', 'Radau' 等)
            plot_times (list): 需要绘图的时间点
            
        返回：
            dict: 包含时间点和温度数组的解决方案数据
        """
        if plot_times is None:  # 设置默认绘图时间点
            plot_times = [0, 1, 5, 15, 25]
            
        # 仅内部节点的初始条件
        u0_internal = self.u_initial[1:-1]
        
        start_time = time.time()  # 开始计时
        
        # 求解 ODE 系统
        sol = solve_ivp(
            fun=self._heat_equation_ode,  # ODE函数
            t_span=(0, self.T_final),  # 时间范围
            y0=u0_internal,  # 初始条件
            method=method,  # 积分方法
            t_eval=plot_times,  # 评估时间点
            rtol=1e-8,  # 相对容差
            atol=1e-10  # 绝对容差
        )
        
        computation_time = time.time() - start_time  # 计算耗时
        
        # 重建包含边界条件的完整解
        results = {
            'times': sol.t.tolist(),  # 时间点列表
            'solutions': [],  # 解决方案列表
            'method': f'solve_ivp ({method})',  # 方法名称
            'computation_time': computation_time  # 计算时间
        }
        
        # 重建每个时间点的完整解
        for i in range(len(sol.t)):
            u_full = np.concatenate(([0.0], sol.y[:, i], [0.0]))  # 添加边界
            results['solutions'].append(u_full)  # 添加到结果
        
        return results
    
    def compare_methods(self, dt_explicit=0.01, dt_implicit=0.1, dt_cn=0.5, 
                       ivp_method='BDF', plot_times=None):
        """
        比较所有四种数值方法
        
        参数：
            dt_explicit (float): 显式方法的时间步长
            dt_implicit (float): 隐式方法的时间步长
            dt_cn (float): Crank-Nicolson 方法的时间步长
            ivp_method (str): solve_ivp 的积分方法
            plot_times (list): 比较的时间点
            
        返回：
            dict: 所有方法的结果
        """
        if plot_times is None:  # 设置默认绘图时间点
            plot_times = [0, 1, 5, 15, 25]
            
        # 打印问题设置信息
        print("Solving heat equation using four different methods...")
        print(f"Domain: [0, {self.L}], Grid points: {self.nx}, Final time: {self.T_final}")
        print(f"Thermal diffusivity: {self.alpha}")
        print("-" * 60)
        
        # 存储所有方法的结果
        methods_results = {}
        
        # 1. 显式方法
        print("1. Explicit finite difference (FTCS)...")
        methods_results['explicit'] = self.solve_explicit(dt_explicit, plot_times)
        print(f"   Computation time: {methods_results['explicit']['computation_time']:.4f} s")
        print(f"   Stability parameter r: {methods_results['explicit']['stability_parameter']:.4f}")
        
        # 2. 隐式方法
        print("2. Implicit finite difference (BTCS)...")
        methods_results['implicit'] = self.solve_implicit(dt_implicit, plot_times)
        print(f"   Computation time: {methods_results['implicit']['computation_time']:.4f} s")
        print(f"   Stability parameter r: {methods_results['implicit']['stability_parameter']:.4f}")
        
        # 3. Crank-Nicolson 方法
        print("3. Crank-Nicolson method...")
        methods_results['crank_nicolson'] = self.solve_crank_nicolson(dt_cn, plot_times)
        print(f"   Computation time: {methods_results['crank_nicolson']['computation_time']:.4f} s")
        print(f"   Stability parameter r: {methods_results['crank_nicolson']['stability_parameter']:.4f}")
        
        # 4. solve_ivp 方法
        print(f"4. solve_ivp method ({ivp_method})...")
        methods_results['solve_ivp'] = self.solve_with_solve_ivp(ivp_method, plot_times)
        print(f"   Computation time: {methods_results['solve_ivp']['computation_time']:.4f} s")
        
        print("-" * 60)
        print("All methods completed successfully!")
        
        return methods_results
    
    def plot_comparison(self, methods_results, save_figure=False, filename='heat_equation_comparison.png'):
        """
        绘制所有方法的比较图
        
        参数：
            methods_results (dict): 来自 compare_methods 的结果
            save_figure (bool): 是否保存图像
            filename (str): 保存图像的文件名
        """
        # 创建2x2子图
        fig, axes = plt.subplots(2, 2, figsize=(15, 12))
        axes = axes.flatten()  # 展平为1D数组
        
        method_names = ['explicit', 'implicit', 'crank_nicolson', 'solve_ivp']  # 方法名称列表
        colors = ['blue', 'red', 'green', 'orange', 'purple']  # 绘图颜色
        
        for idx, method_name in enumerate(method_names):  # 遍历每种方法
            ax = axes[idx]  # 当前子图
            results = methods_results[method_name]  # 当前方法的结果
            
            # 在不同时间绘制解
            for i, (t, u) in enumerate(zip(results['times'], results['solutions'])):
                ax.plot(self.x, u, color=colors[i], label=f't = {t:.1f}', linewidth=2)
            
            # 设置子图标题和标签
            ax.set_title(f"{results['method']}\n(Time: {results['computation_time']:.4f} s)")
            ax.set_xlabel('Position x')
            ax.set_ylabel('Temperature u(x,t)')
            ax.grid(True, alpha=0.3)  # 添加半透明网格
            ax.legend()  # 添加图例
            ax.set_xlim(0, self.L)  # X轴范围
            ax.set_ylim(-0.1, 1.1)  # Y轴范围
        
        plt.tight_layout()  # 调整子图间距
        
        if save_figure:  # 如果需要保存图像
            plt.savefig(filename, dpi=300, bbox_inches='tight')
            print(f"Figure saved as {filename}")
        
        plt.show()  # 显示图像
    
    def analyze_accuracy(self, methods_results, reference_method='solve_ivp'):
        """
        分析不同方法的准确性
        
        参数：
            methods_results (dict): 来自 compare_methods 的结果
            reference_method (str): 用作参考的方法
            
        返回：
            dict: 准确性分析结果
        """
        if reference_method not in methods_results:  # 检查参考方法是否存在
            raise ValueError(f"Reference method '{reference_method}' not found in results")
        
        reference = methods_results[reference_method]  # 参考方法结果
        accuracy_results = {}  # 准确性结果字典
        
        # 打印分析标题
        print(f"\nAccuracy Analysis (Reference: {reference['method']})")
        print("-" * 50)
        
        for method_name, results in methods_results.items():  # 遍历所有方法
            if method_name == reference_method:  # 跳过参考方法
                continue
                
            errors = []  # 误差列表
            # 比较每个时间点的解
            for i, (ref_sol, test_sol) in enumerate(zip(reference['solutions'], results['solutions'])):
                if i < len(results['solutions']):  # 确保索引有效
                    # 计算L2范数误差
                    error = np.linalg.norm(ref_sol - test_sol, ord=2)
                    errors.append(error)  # 添加到误差列表
            
            # 计算最大和平均误差
            max_error = max(errors) if errors else 0
            avg_error = np.mean(errors) if errors else 0
            
            # 存储结果
            accuracy_results[method_name] = {
                'max_error': max_error,
                'avg_error': avg_error,
                'errors': errors
            }
            
            # 打印结果
            print(f"{results['method']:25} - Max Error: {max_error:.2e}, Avg Error: {avg_error:.2e}")
        
        return accuracy_results


def main():
    """
    HeatEquationSolver 类的演示函数
    """
    # 创建求解器实例
    solver = HeatEquationSolver(L=20.0, alpha=10.0, nx=21, T_final=25.0)
    
    # 比较所有方法
    plot_times = [0, 1, 5, 15, 25]  # 比较的时间点
    results = solver.compare_methods(
        dt_explicit=0.01,  # 显式方法时间步长
        dt_implicit=0.1,   # 隐式方法时间步长
        dt_cn=0.5,         # Crank-Nicolson方法时间步长
        ivp_method='BDF',   # solve_ivp方法
        plot_times=plot_times
    )
    
    # 绘制比较图
    solver.plot_comparison(results, save_figure=True)
    
    # 分析准确性
    accuracy = solver.analyze_accuracy(results, reference_method='solve_ivp')
    
    return solver, results, accuracy


if __name__ == "__main__":
    # 当直接运行脚本时执行主函数
    solver, results, accuracy = main()]


